---
title: "Pattern break detection"
author: "Othman El Hammouchi"
output: "pdf_document"
header_includes:
    - \usepackage{amsmath}
---
```{r, echo = FALSE}
suppressPackageStartupMessages({
    library(MASS)
    library(ggplot2)
    library(ChainLadder)
    library(knitr)
    library(data.table)
    library(iterators)
    library(parallel)
    library(doParallel)
    library(foreach)
    library(moments)

    registerDoParallel()

    source("pattern_break.r")
})

suppressMessages({
    knitr::opts_chunk$set(echo = FALSE)
})
```

\section{Introduction}

Stochastic claims reserving methods in non-life insurance are based on models whose underlying assumptions are difficult to verify using classical statistical inference owing to the limited amount of data that's typically available. A possible way to remedy this, which we will explore in this notebook, is through the use of bootstrap simulation. The idea is to start from a sythetic triangle which is constructed to perfectly satisfy some set of assumptions, and then to gauge the sensitivity of the simulated reserve to deviations from said assumptions. We will do this by applying various violations and studying the effect on the bootstrapped predictive distribution. If a significant effect is observed, this suggests a method for identifying observations in real claims data which do not conform to the given model.

\section{Perturbing a single observation}

Let's start by considering the underlying model of Mack's method, which is one the most popular reserving techniques. It makes the following assumptions:

\begin{gather}
\mathbb{E}[C_{ij} \ \Vert \ C_{i, j - 1}, \dots, C_{i1}] = \mathbb{E}[C_{ij} \ \Vert \ C_{i, j - 1}] = f_{j - 1} C_{i, j - 1} \\
\mathrm{Var}[C_{ij} \ \Vert \ C_{i, j - 1}, \dots, C_{i1}] = \mathrm{Var}[C_{ij} \ \Vert \ C_{i, j - 1}] = \sigma_{j - 1}^2 C_{i, j - 1}
\end{gather},
for $i \in \{ 0, \dots, I \}$ and
\begin{equation}
\{ C_{i, 0}, \dots, C_{i, I - i} \}, \{ C_{i', 0}, \dots, C_{i', I - i'} \} \ \text{independent for} \ i \neq i' \,.
\end{equation}

The first violation we consider is of the mean assumption. We can repeat the simulation for every possible point and a range of perturbations between 0.5 and 1.5. 

triangle conforming to Mack's assumptions. For added realism, we borrow the development factors and $\sigma_j$-parameters from a real dataset, the UKMotor data from the `ChainLadder` package.

The problem with using the above normal model is that it allows for negative samples during the bootstrap simulation. To avoid this, we can use a different distribution which still respects Mack's assumptions. If we take for instance $C_{ij} \sim \Gamma(\alpha, \beta)$, then we must choose $\alpha, \beta$ to satisfy
\begin{displaymath}
\begin{cases}
\frac{\alpha}{\beta} = f_{j-1} C_{i, j-1} \\
\frac{\alpha}{\beta^2} = \sigma^2_{j-1} C_{i, j-1} \,,
\end{cases}
\end{displaymath}
giving the values
\begin{gather*}
\alpha = \frac{f_{j-1}^2 C_{i, j-1}}{\sigma_{j-1}^2} \\
\beta = \frac{f_{j-1}}{\sigma_{j-1}^2} \,,
\end{gather*}
for the distribution parameters.

```{r}
set.seed(5)

# extract simulation parameters from benchmark data
ndev <- ncol(UKMotor)

benchmark <- sapply(1:(ndev - 1), function(i) {

    model <- lm(y ~ x + 0,
        data = data.frame(x = UKMotor[1:(ndev - i), i], y = UKMotor[1:(ndev - i), i + 1]),
        weights = 1 / UKMotor[1:(ndev - i), i])

    return(c(model$coefficients, summary(model)$sigma))
})

devfacs <- benchmark[1, ]
sigmas <- benchmark[2, ]
sigmas[length(sigmas)] <- sqrt(min(sigmas[(length(sigmas) - 2)]**2, sigmas[length(sigmas) - 1]**2, sigmas[length(sigmas) - 1]**4 / sigmas[(length(sigmas) - 2)]**2))

# simulate triangle
initcol <- unname(UKMotor[, 1])

claims.triangle <- matrix(ncol = ndev, nrow = ndev)
claims.triangle[, 1] <- initcol

for (colidx in 2:ndev) {
    for (rowIdx in 1:(ndev + 1 - colidx)) {
        prevC <- claims.triangle[rowIdx, colidx - 1]
        claims.triangle[rowIdx, colidx] <-
            rnorm(1, devfacs[colidx - 1] * prevC, sigmas[colidx - 1] * sqrt(prevC))
    }
}

kable(claims.triangle)
```

As expected, the Mack estimator performs very well in this case:

```{r}
res <- MackChainLadder(claimsTriangle)

print(res$f)
```

-- Describe that there are multiple ways of doing the bootstrap, depending on how parameter estimation error is quantified, assumptions on the residuals and choice of distribution for incorporating process error --

-- Describe the first class of experiments: we perturb a single observation by drawing from a normal distribution whose mean is multiplied with a given factor. This corresponds to scaling the mean of the corresponding individual development factor from the link ratio adhered to by the rest of the column by that factor. --

```{r}

# create table of experiment configurations
points <- c()

for (colidx in 2:ndev) {
    nrows <- ndev + 1 - colidx
    points <- rbind(points, cbind(1:nrows, rep(colidx, nrows)))
}

pertfacs <- seq(0.5, 1.5, by = 0.25)

residual.types <- c("parametric", "raw", "scaled")
bootstrap.types <- c("conditional", "unconditional")

indices <- expand.grid(seq_len(nrow(points)), seq_len(length(pertfacs)), seq_len(length(residual.types)), seq_len(length(bootstrap.types)))

config <- cbind.data.frame(points[indices[, 1], ], pertfacs[indices[, 2]], residual.types[indices[, 3]], bootstrap.types[indices[, 4]])

# experiment loop
results <- foreach(config = iter(config, by = "row"), .combine = "rbind", .errorhandling = "stop") %dopar% {

                outlier.rowidx <- config[[1]]
                outlier.colidx <- config[[2]]
                pertfac <- config[[3]]

                distortedTriangle <- singleOutlier(outlier.rowidx, outlier.colidx, pertfac,
                    initcol = initcol,
                    devfacs = devfacs,
                    sigmas = sigmas)

                residuals.type <- config[[4]]
                bootstrap.type <- config[[5]]

                reserve <- reserveBootFortran(distortedTriangle, 1e3,
                    distribution = "gamma",
                    resids.type = residuals.type,
                    bootstrap.type = bootstrap.type
                )

                row <- data.table(
                    residuals.type = residuals.type,
                    bootstrap.type = bootstrap.type,
                    outlier.rowidx = outlier.rowidx,
                    outlier.colidx = outlier.colidx,
                    pertfac = pertfac,
                    reserve = list(reserve))

        }

stopImplicitCluster()
```

For the columns, there seems to be a lot of variation if the perturbation is applied early, which makes it difficult to distinguish problematic points in earlier columns. Later columns seem to exhibit a clearer influence.

For the rows, the reverse it true: perturbations in earlier rows are more easily distinguished than in later ones.

```{r}
ggplot(results[, .(reserve = unlist(reserve)), by = setdiff(names(results), "reserve")]) +
    geom_histogram(aes(x = reserve, fill = factor(pertfac))) +
    facet_wrap(outlier.colidx ~ outlier.rowidx, scales = "free", labeller = "label_both")

ggsave("results/graphs/single_outlier_prestudy_distributions.eps")

```

```{r}
methods <- unique(results[, .(residuals.type, bootstrap.type)])

for (i in seq_len(nrow(methods))) {

ggplot(
    results[residuals.type == methods[i, residuals.type] & bootstrap.type == methods[i, bootstrap.type],
 .(mean = sapply(reserve, mean, na.rm = TRUE)),
  by = setdiff(names(results), "reserve")
  ]) +
    geom_point(aes(pertfac, mean, colour = outlier.rowidx)) +
    facet_wrap(vars(outlier.colidx), scales = "free") +
    labs(x = "Perturbation factor", y = "Bootstrap mean") +
    ggtitle("Reserve estimates for different perturbed columns",
        subtitle = sprintf("Residuals type: %s\n Bootstrap type: %s", methods[i, residuals.type], methods[i, bootstrap.type]))

ggsave(sprintf("results/graphs/single_outlier_prestudy_%s_%s.eps", methods[i, residuals.type], methods[i, bootstrap.type]))

}

```

Now we want to go in the reverse direction: if we start from a perturbed triangle, does removal of the outlying observation create a significant difference in the reserve?

```{r}
if (exists("results/data_objects/single_outlier.RDS")) {

    readRDS("results/data_objects/single_outlier.RDS")

} else {

    # create table of experiment configurations
    points <- c()

    for (colidx in 2:ndev) {
        nrows <- ndev + 1 - colidx
        points <- rbind(points, cbind(1:nrows, rep(colidx, nrows)))
    }

    pertfac <- seq(0.5, 1.5, by = 0.25)

    residual.types <- c("parametric", "raw", "scaled")
    bootstrap.types <- c("conditional", "unconditional")
    distributions <- c("normal", "gamma")

    config <- genConfig(points, pertfac, points, residual.types, bootstrap.types, distributions)

    # experiment loop
    results <- foreach(config = iter(config, by = "row"), .combine = "rbind", .errorhandling = "stop") %dopar% {

        outlier.rowidx <- config[[1]]
        outlier.colidx <- config[[2]]
        pertfac <- config[[3]]
        excl.rowidx <- config[[4]]
        excl.colidx <- config[[5]]
        resids.type <- config[[6]]
        bootstrap.type <- config[[7]]
        distribution <- config[[8]]

        distortedTriangle <- singleOutlier(outlier.rowidx, outlier.colidx, pertfac,
            initcol = initcol,
            devfacs = devfacs,
            sigmas = sigmas,
        distribution = distribution)

        exclude.residuals <- list(c(excl.rowidx, excl.colidx))

        reserve <- reserveBootFortran(distortedTriangle, 1e3,
            excl.resids = exclude.residuals,
            distribution = distribution,
            resids.type = resids.type,
            bootstrap.type = bootstrap.type
        )

        row <- data.table(
            outlier.rowidx = outlier.rowidx,
            outlier.colidx = outlier.colidx,
            pertfac = pertfac,
            excl.rowidx = excl.rowidx,
            excl.colidx = excl.colidx,
            distribution = distribution,
            resids.type = resids.type,
            bootstrap.type = bootstrap.type,
            reserve = list(reserve))
    }

    stopImplicitCluster()

    results[, c("mean", "sd", "kurtosis") := .(sapply(reserve, mean), sapply(reserve, sd), sapply(reserve, kurtosis))]

    saveRDS(results, "results/data_objects/single_outlier.RDS")
}

```

```{r}
unique(results[(mean < 0 | is.nan(mean)) & distribution == "gamma"]$resids.type)
```

```{r}
options <- expand.grid(pertfac, residual.types, bootstrap.types, distributions)

for (i in nrow(options)) {

    factor <- options[i, 1]
    resids.type <- options[i, 2]
    bootstrap.type <- options[i, 3]
    distribution <- options[i, 4]


    ggplot() +
        geom_density(
            data = results[resids.type == resids.type, bootstrap.type == bootstrap.type, distribution == distribution, pertfac == factor & outlier.colidx != excl.colidx & outlier.rowidx != excl.rowidx, .(reserve = unlist(reserve)), by = setdiff(names(results), "reserve")],
            aes(x = reserve, group = excl.colidx), alpha = 0.7,
        ) +
        geom_density(
            data = results[resids.type == resids.type, bootstrap.type == bootstrap.type, distribution == distribution, pertfac == factor & outlier.colidx == excl.colidx & outlier.rowidx == excl.rowidx, .(reserve = unlist(reserve)), by = setdiff(names(results), "reserve")],
            aes(x = reserve), colour = "red") +
        facet_wrap(vars(outlier.rowidx, outlier.colidx), scales = "free") +
        ggtitle("Reserve distributions for different outlier points",
            subtitle = sprintf("Perturbation factor: %f", factor))

    ggsave(sprintf("results/graphs/single_outlier/densities_distribution_%s_pertfac_%f_residstype_%s_bootstraptype_%s.eps", distribution, factor, resids.type, bootstrap.type))

}
```

```{r}
ggplot(results) +
    geom_violin(aes(factor(pertfac), mean)) +
    geom_point(data = results[outlier.colidx == excl.colidx & outlier.rowidx == excl.rowidx], aes(factor(pertfac), mean), colour = "red") +
    facet_wrap(vars(outlier.colidx, outlier.rowidx), scales = "free", labeller = "label_both") +
    ggtitle("Reserve mean for different outlier points")

ggsave("results/graphs/single_outlier/normal_mean.eps")

ggplot(results) +
    geom_violin(aes(factor(pertfac), sd)) +
    geom_point(data = results[outlier.colidx == excl.colidx & outlier.rowidx == excl.rowidx], aes(factor(pertfac), sd), colour = "red") +
    facet_wrap(vars(outlier.colidx, outlier.rowidx), scales = "free", labeller = "label_both") +
    ggtitle("Reserve sd for different outlier points")

ggsave("results/graphs/single_outlier/normal_sd.eps")

ggplot(results) +
    geom_violin(aes(factor(pertfac), kurtosis)) +
    geom_point(data = results[outlier.colidx == excl.colidx & outlier.rowidx == excl.rowidx], aes(factor(pertfac), kurtosis), colour = "red") +
    facet_wrap(vars(outlier.colidx, outlier.rowidx), scales = "free", labeller = "label_both") +
    ggtitle("Reserve kurtosis for different outlier points")

ggsave("results/graphs/single_outlier/normal_kurtosis.eps")

```

\section{Perturbing a calendar year}

Now instead of perturbing a single observation, we perturb an entire calendar year.

```{r}
if (exists("results/data_objects/calendar_year.RDS")) {

    readRDS("results/data_objects/calendar_year.RDS")

} else {

    # create table of experiment configurations
    diagidx <- 0:6
    pertfac <- seq(0.5, 1.5, by = 0.25)

    indices <- expand.grid(seq_len(length(diagidx)), seq_len(length(pertfac)), seq_len(length(diagidx)))

    config <- cbind(diagidx[indices[, 1]], pertfac[indices[, 2]], diagidx[indices[, 3]])

    # experiment loop
    results <- foreach(config = iter(config, by = "row"), .combine = "rbind", .errorhandling = "stop") %dopar% {

        outlier.diagidx <- config[1]
        pertfac <- config[2]

        distorted.triangle <- calendarOutlier(outlier.diagidx, pertfac,
            initcol = initcol,
            devfacs = devfacs,
            sigmas = sigmas)

        excl.diagidx <- config[3]

        exclude.residuals <- list()

        for (colidx in 2:ndev) {
            diag.rowidx <- ndev + 1 - excl.diagidx - colidx
            if (diag.rowidx > 0) {
                exclude.residuals <- c(exclude.residuals, list(c(diag.rowidx, colidx)))
            }
        }

        reserve <- reserveBoot(distorted.triangle, 1e3, exclude.residuals = exclude.residuals)

        row <- data.table(
            outlier.diagidx = outlier.diagidx,
            pertfac = pertfac,
            excl.diagidx = excl.diagidx,
            reserve = list(reserve))

    }

    stopImplicitCluster()

    results[, c("mean", "sd", "kurtosis") := .(sapply(reserve, mean), sapply(reserve, sd), sapply(reserve, kurtosis))]

    saveRDS(results, "results/data_objects/calendar_year.RDS")
}

```

```{r}
ggplot(results) +
    geom_violin(aes(factor(pertfac), mean)) +
    geom_point(data = results[outlier.diagidx == excl.diagidx], aes(factor(pertfac), mean)) +
    facet_wrap(vars(outlier.diagidx), scales = "free", labeller = "label_both") +
    ggtitle("Reserve mean for different outlier points")

ggsave("results/graphs/calendar_outlier_mean.eps")

ggplot(results) +
    geom_violin(aes(factor(pertfac), sd)) +
    geom_point(data = results[outlier.diagidx == excl.diagidx], aes(factor(pertfac), sd)) +
    facet_wrap(vars(outlier.diagidx), scales = "free", labeller = "label_both") +
    ggtitle("Reserve sd for different outlier points")

ggsave("results/graphs/calendar_outlier_sd.eps")

ggplot(results) +
    geom_violin(aes(factor(pertfac), kurtosis)) +
    geom_point(data = results[outlier.diagidx == excl.diagidx], aes(factor(pertfac), kurtosis)) +
    facet_wrap(vars(outlier.diagidx), scales = "free", labeller = "label_both") +
    ggtitle("Reserve kurtosis for different outlier points")

ggsave("results/graphs/calendar_outlier_kurtosis.eps")

```


\section{Perturbing an accident year}

```{r}
if (exists("results/data_objects/calendar_year.RDS")) {

    readRDS("results/data_objects/calendar_year.RDS")

} else {

    # create table of experiment configurations
    points <- c()

    for (colIdx in 2:ndev) {
        nRows <- ndev + 1 - colIdx
        points <- rbind(points, cbind(1:nRows, rep(colIdx, nRows)))
    }

    pertFac <- seq(0.5, 1.5, by = 0.25)

    indices <- expand.grid(seq_len(nrow(points)), seq_len(length(pertFac)), seq_len(nrow(points)))

    config <- cbind(points[indices[, 1], ], pertFac[indices[, 2]], points[indices[, 3], ])

    # experiment loop
    singleOutlierResult <- foreach(config = iterator(config, by = "row"), .combine = "rbind", .errorhandling = "stop") %dopar% {

        outlierRowIdx <- config[1]
        outlierColIdx <- config[2]
        pertFac <- config[3]

        distortedTriangle <- singleOutlier(outlierColIdx, outlierRowIdx, pertFac,
            initCol = initCol,
            devFacs = devFacs,
            sigma = sigma)

        exclRowIdx <- config[4]
        exclColIdx <- config[5]

        exclude_residuals <- list(c(exclRowIdx, exclColIdx))

        reserve <- reserveBoot(distortedTriangle, 1e3, exclude_residuals = exclude_residuals)

        row <- data.table(outlierRowIdx = outlierRowIdx, outlierColIdx = outlierColIdx, pertFac = pertFac, exclRowIdx = exclRowIdx, exclColIdx = exclColIdx)

    }

    results[]

    saveRDS(results, "results/data_objects/calendar_year.RDS")
}

```